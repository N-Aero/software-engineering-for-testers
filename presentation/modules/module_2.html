<section>
    <h2>Module 2</h2>
    <h3>Clean code</h3>
</section>

<section>
    <h2>Topics</h2>
    <ul>
        <li>Meaningful names</li>
        <li>Functions</li>
        <li>Comments</li>
        <li>Formatting</li>
        <li>Objects & data structures</li>
        <li>Error handling</li>
        <li>Boundaries</li>
        <li>Unit tests</li>
        <li>Classes</li>
    </ul>
</section>

<section>
    <h3>Meaningsful names</h3>
</section>

<section>
    <h3>Use meaningful, readable variable names</h3>

    <pre><code data-trim data-noescape>
        int d;
        // elapsed time in days
        int ds;
        int dsm;
        int faid;
    </code></pre>
</section>

<section>
    <h3>Use meaningful, readable variable names</h3>

    <pre><code data-trim data-noescape>
        int elapsedTimeInDays;
        int daysSinceCreation;
        int daysSinceModification;
        int fileAgeInDays;
    </code></pre>
</section>

<section>
    <h4>Use Intention Revealing Names</h4>
    <pre><code data-trim data-noescape>
        public List&lt;int[]&gt; getThem() {
            List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();
            for (int[] x : theList)
                if (x[0] == 4)
                    list1.add(x);
            return list1;
        }
    </code></pre>
</section>

<section>
    <h4>Use Intention Revealing Names</h4>
    <pre><code data-trim data-noescape>
        public List&lt;int[]&gt; getFlaggedCells() {
            List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;();
            for (int[] cell : gameBoard)
                if (cell[STATUS_VALUE] == FLAGGED)
                    flaggedCells.add(cell);
            return flaggedCells;
        }
    </code></pre>
</section>

<section>
    <h4>Searchable Names</h4>
    <pre><code data-trim data-noescape>
        int d;
        int e;
        int x;
        int z;
    </code></pre>
</section>

<section>
    <h4>Favor Readability over brevity</h4>
    <br />
    <p><b><em>CanScrollHorizontally</em></b> is better than <b><em>ScrollableX.</em></b></p>
</section>

<section>
    <h4>One word per concept</h4>
    <p>TODO add UML image where naming per concept is highlighted</p>
</section>

<section>
    <h4>Don't be cute</h4>
    <p>Funny names remain understandable only as long as you and the people who share the joke stay on the project.</p>
</section>

<section>
    <h4>Classes</h4>
    <p>
        "Classes and objects should have noun or noun phrase names like Customer, WikiPage,
        Account, and AddressParser. Avoid words like Manager, Processor, Data, or Info in the name
        of a class. A class name should not be a verb."
    </p>
    <p>
        Clean code - Uncle Bob
    </p>
</section>

<section>
    <h4>Methods</h4>
    <p>
        Methods should have verb (phrase) naming. Accessors, mutators and predicates should start with get, set or is.
    </p>
</section>

<section>
    <h4>Smart constructors</h4>
    <p>
        Use smart constructors when overloading the constructor.
    </p>
    <p>
    <pre><code data-trim data-noescape>
            Complex fulcrumPoint = Complex.FromRealNumber(23.0);
            
            Complex fulcrumPoint = new Complex(23.0);
        </code></pre>
    </p>
</section>

<section>
    <h1>Functions</h1>

    <ul>
        <li>Small</li>
        <li>Do one thing</li>
        <li>Have explanatory names</li>
    </ul>
</section>

<section>
    <h2>Not to many arguments</h2>

    <p>
        If your function has to many arguments, they most
        like are connected and should be wrapped in an object
    </p>
</section>

<section>
    <h2>Command query Separation</h2>

    <pre><code data-trim data-noescape>
        public boolean set(String attribute, String value);
    </code></pre>

    <pre><code data-trim data-noescape>
        public boolean set(String attribute, String value);

        if (set("username", "unclebob"))
    </code></pre>

    <pre><code data-trim data-noescape>
        if (attributeExists("username")) {
            setAttribute("username", "unclebob");
        }
    </code></pre>

</section>

<section>
    <h1>Comments</h1>
</section>

<section>
    <h2>Comments are last resort</h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        // Check to see if the employee is eligible for full benefits
        if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
    </code></pre>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        if (employee.isEligibleForFullBenefits())
    </code></pre>


    <aside class="notes">
        <ul>
            <li>Comments do not make up for bad code, they often lie.</li>
            <li>For that reason, prefer readable code instead of comments</li>
        </ul>
    </aside>

</section>

<section>
    <h2>Function / Variables > Comments</h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        
    // does the module from the global list <mod> depend on the
    // subsystem we are part of?
    if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem()))
    </code></pre>

    <pre class="fragment fade-in"><code data-trim data-noescape>       
        ArrayList moduleDependees = smodule.getDependSubsystems();
        String ourSubSystem = subSysMod.getSubSystem();
        if (moduleDependees.contains(ourSubSystem))
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Another example where we can use proper naming and variables / functions to have the same readability as
                the comment</li>
        </ul>
    </aside>

</section>

<section>
    <h2>Comments will lie</h2>

    <aside class="notes">
        <ul>
            <li>Comments will lie at a certain point of time because there is no correlation between the code and the
                comment.</li>
            <li>Whenever you refactor, there is no guarantee that you also change the comment which will result in lying
                comments</li>
        </ul>
    </aside>

</section>

<section>
    <h2>Redundant / Noisy comments</h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        
        /** The name. */
        private String name;

        /** The version. */
        private String version;

        /** The licenceName. */
        private String licenceName;
        
        /** The info. */
        private String info;
    </code></pre>

    <aside class="notes">
        <ul>
            <li>These comments do add nothing, only noise</li>
        </ul>
    </aside>

</section>

<!-- <section>
    <h1>Objects and Data Structures</h1>

    <aside class="notes">

    </aside>
</section> -->
<!-- 
<section>
    <h2>The law of demeter</h2>

    <aside class="notes">
        // TODO
    </aside>
</section> -->

<section>
    <h2>Data Transfer Objects (DTO)</h2>

    <aside class="notes">
        // TODO
    </aside>
</section>

<section>
    <h2>Active records</h2>

    <aside class="notes">
        // TODO
    </aside>
</section>

<section>
    <h2>Use unchecked exceptions</h2>

    <aside class="notes">
        <ul>
            <li>Checked exceptions break the open/closed principle.</li>
            <li>If you have an exception that is thrown three layers lower, all the layers need to explicitly declare
                the exception</li>
            <li>Checked exceptions can be useful when writing a critical library because you MUST handle then</li>
            <li>When doing application development, the cost outweigh the benefits</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Create context with exceptions</h2>

    <aside class="notes">
        <ul>
            <li>The exception should provide enough context to determine the source and location of an error</li>
            <li>It should explain the intent of why the operation failed</li>
            <li>Add informative error messages with the exceptions. It allows you to improve logging and gives the
                developer more info of why something failed.</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Don't return null</h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        public void registerItem(Item item) {
            if (item != null) {
                ItemRegistry registry = peristentStore.getItemRegistry();
                if (registry != null) {
                    Item existing = registry.getItem(item.getID());
                    if (existing.getBillingPeriod().hasRetailOwner()) {
                        existing.register(item); }
                    }
                }
            }
        }
    </code></pre>

    <aside class="notes">
        <ul>
            <li>Do you spot the mistake? What if getItem returns null? Because of all the null checks we declutter the
                code</li>
            <li>A missing null check can result in the application to halt (NullPointerException)</li>
            <li>Prefer exceptions or Special Case object instead.</li>
        </ul>
    </aside>
</section>

<section>
    <h2></h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        List<Employee> employees = getEmployees();
        if (employees != null) {
            for(Employee e : employees) {
                totalPay += e.getPay();
            }
        }
    </code></pre>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        // Get employees
        public List<Employee> getEmployees() {
            if (no employees) {
                return Collections.emptyList();
            }
        }

        List<Employee> employees = getEmployees();
        for(Employee e : employees) {
            totalPay += e.getPay();
        }
    </code></pre>

    <aside class="notes">
    </aside>
</section>

<section>
    <h2>Use optional as typesafe null alternative</h2>

    <pre class="fragment fade-in"><code data-trim data-noescape>
        public void registerItem(Item item) {
            Optional<ItemRegistry> optionalRegistry = peristentStore.getItemRegistry();
            optionalRegistry
                .flatMap(registry -> registry.getItem(item.getID()))
                .flatMap(existing -> {
                    if (existing.getBillingPeriod().hasRetailOwner()) {
                        return existing.register(item);
                    }
                });
        }
    </code></pre>

    <aside class="notes">
    </aside>
</section>

<section>
    <h2>Don't pass null</h2>

    <aside class="notes">
        <ul>
            <li>If we allow nulls in function, it means that everywhere in our code the argument list needs to be checked by null</li>
        </ul>
    </aside>
</section>

<section>
    <h2>Gilded Rose Refactoring kata</h2>

    <ul>
        <li class="fragment fade-in">Go to exercises/CleanCode</li>
        <li class="fragment fade-in">Run mvn clean install to see if you get the project to run (1 test fail)</li>
        <li class="fragment fade-in"> Write unit tests to ensure the application works as you would expect</li>
        <li class="fragment fade-in">Start refactoring by applying the clean code rules (and more)</li>
    </ul>
</section>